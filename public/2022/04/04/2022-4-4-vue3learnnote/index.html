

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



    <head>
        <meta charset="UTF-8">
        <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
        <link rel="icon" type="image/png" href="/img/blogicon.png">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <!-- 谷歌广告 -->
        <script data-ad-client="ca-pub-2387054913975173" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
        </script>
        
                <meta name="theme-color" content="#2f4154">
                <meta name="description" content="软件爱好者，分享好玩有趣的效率工具或软件，致力成为国内优质的工具测评媒体">
                <meta name="author" content="Angola Peng">
                <meta name="keywords" content="效率工具,软件,Macbook,前端,工具,App,博客,写作">
                <title>
                    前端框架 Vue3 学习笔记（一） - 彭宏豪的个人博客，个人电子产品使用心得
                </title>

                <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


                    <script  src="/js/utils.js" ></script>
                        <script  src="/js/color-schema.js" ></script>
    <meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="彭宏豪的个人博客，个人电子产品使用心得" type="application/atom+xml">
</head>

<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>效率工具指南</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/sport/">
                <i class="iconfont icon-map"></i>
                跑步
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-04 10:17" pubdate>
        2022年4月4日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      143
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-post-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-post-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
    <a target="_blank" rel="noopener" href="https://github.com/phh95/hexo_blog" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0; z-index: 1031;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">前端框架 Vue3 学习笔记（一）</h1>
            
            <div class="markdown-body" id="post-body">
              <p>注：学习笔记来自 coderwhy 老师的 Vue3 课程。  </p>
<p>Vue 是一种面向数据的编程，在 Vue 应用中定义了数据和模板，Vue 就会自动把数据和模板关联起来，变成 HTML 页面想要展示的效果。   </p>
<p>Vue 这种面向数据编程的模式，是参考了 MVVM 这种设计模式。  </p>
<p>M 代表 Model，也就是数据。<br>V 代表 View，视图。对应 Vue 实例中的 template。<br>VM 代表 ViewModel，视图数据连接层。把数据和模板关联起来，是 Vue 的<strong>组件</strong>帮我们做的。  </p>
<p>下图把 Vue 应用返回的根组件，起名叫做 vm。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16466608169086.jpg" srcset="/img/loading.gif"></p>
<h2 id="Vue-的生命周期函数"><a href="#Vue-的生命周期函数" class="headerlink" title="Vue 的生命周期函数"></a>Vue 的生命周期函数</h2><p>生命周期函数：在某一时刻会自动执行的函数。   </p>
<p>下面是 coderwhy 老师的视频课程：  </p>
<h2 id="Vue-在前端处于什么地位？"><a href="#Vue-在前端处于什么地位？" class="headerlink" title="Vue 在前端处于什么地位？"></a>Vue 在前端处于什么地位？</h2><p>主流的 3 大框架：Vue、React、Angular  </p>
<p>Angular：入门门槛较高，并且国内市场占有率较低；不否认本身是一个非常优秀的框架   </p>
<p>React：在国内外的市场占有率都是非常高的，作为前端工程师也是必须学习的一个框架   </p>
<p>Vue：在国内市场占有率是最高的，几乎所有的前端岗位都会对 Vue 有要求   </p>
<h3 id="学习哪一门语言更容易找到工作？"><a href="#学习哪一门语言更容易找到工作？" class="headerlink" title="学习哪一门语言更容易找到工作？"></a>学习哪一门语言更容易找到工作？</h3><p>找后端的工作：优先推荐 Java、其次推荐 Go、再次推荐 Node  </p>
<p>找前端的工作：优先推荐 JS(TypeScript)、其次 Flutter、再次 Android(Java、Kotlin)、iOS(OC、Swift)  </p>
<p>在国内找前端工作，优先推荐学习 Vue，其次是 React。  </p>
<h3 id="学习-Vue2-还是-Vue3？"><a href="#学习-Vue2-还是-Vue3？" class="headerlink" title="学习 Vue2 还是 Vue3？"></a>学习 Vue2 还是 Vue3？</h3><p>尤雨溪：<strong>直接学 Vue 3 就行了</strong>，基础概念是一样的。   </p>
<p>2020 年的 9 月 19 日，Vue3 正式发布，命名为 One Piece。  </p>
<p>Vue 3 带来了很多新的特性：更好的性能、更小的包体积、更好的 TypeScript 集成、更优秀的 API 设计。   </p>
<h3 id="Vue3-带来的变化（源码）"><a href="#Vue3-带来的变化（源码）" class="headerlink" title="Vue3 带来的变化（源码）"></a>Vue3 带来的变化（源码）</h3><ul>
<li>源码通过 monorepo 的形式来管理代码</li>
<li>源码使用 TypeScript 来进行重写（在 Vue2.x 的时候，Vue 使用 Flow 来进行类型检测）   </li>
</ul>
<h3 id="Vue3-带来的变化（性能）"><a href="#Vue3-带来的变化（性能）" class="headerlink" title="Vue3 带来的变化（性能）"></a>Vue3 带来的变化（性能）</h3><ul>
<li>使用 Proxy 进行数据劫持   </li>
<li>删除了一些不必要的 API   </li>
<li>编译方面的优化（生成 Block Tree、Slot 编译优化、diff 算法优化）  </li>
</ul>
<h3 id="Vue3-带来的变化（新的-API）"><a href="#Vue3-带来的变化（新的-API）" class="headerlink" title="Vue3 带来的变化（新的 API）"></a>Vue3 带来的变化（新的 API）</h3><ul>
<li>由 Options API 到 Composition API（Options API 包括 data、props、methods、computed、生命周期等等选项）   </li>
<li>Hooks 函数增加代码的复用性（Vue2.x 通常通过 mixins 在多个组件之间共享逻辑）    </li>
</ul>
<h2 id="如何使用-Vue-呢？"><a href="#如何使用-Vue-呢？" class="headerlink" title="如何使用 Vue 呢？"></a>如何使用 Vue 呢？</h2><ul>
<li>通过 CDN 的方式引入   </li>
<li>下载 Vue 的 JS 文件，手动引入   </li>
<li>通过 npm 包管理工具安装使用   </li>
<li>直接通过 Vue CLI 创建项目，并且使用它    </li>
</ul>
<h3 id="CDN-引入"><a href="#CDN-引入" class="headerlink" title="CDN 引入"></a>CDN 引入</h3><p>CDN 称之为内容分发网络（Content Delivery Network 或 Content Distribution Network，缩写 CDN）。  </p>
<ul>
<li>CDN 是指通过相互连接的网络系统，利用最靠近每个用户的服务器；   </li>
<li>更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户；  </li>
<li>来提供高性能、可扩展性及低成本的网络内容传递给用户  </li>
</ul>
<p>常用的 CDN 服务器可以大致分为两种：   </p>
<ul>
<li>自己的 CDN 服务器</li>
<li>开源的 CDN 服务器：国际上使用比较多的是 unpkg、JSDelivr、cdnjs  </li>
</ul>
<p>Vue 的 CDN 引入：   </p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<h2 id="MVVM-模型"><a href="#MVVM-模型" class="headerlink" title="MVVM 模型"></a>MVVM 模型</h2><p>MVC 和 MVVM 都是一种软件的体系结构。   </p>
<p>MVC 是 Model-View-Controller 的简称，在前期被使用的架构模式，比如 iOS、前端；   </p>
<p>MVVM 是 Model-View-ViewModel 的简称，是目前非常流行的架构模式。  </p>
<p>通常情况下，我们也经常称 Vue 是一个 MVVM 的框架。   </p>
<p>Vue 官方其实有说明：Vue 虽然并没有完全遵守 MVVM 的模型，但是整个设计是受到它的启发的。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16470544025119.jpg" srcset="/img/loading.gif"></p>
<h3 id="template-属性"><a href="#template-属性" class="headerlink" title="template 属性"></a>template 属性</h3><p>HTML 原生提供了 <code>&lt;template&gt;</code> 标签，只不过 template 标签包含的内容，是不会被浏览器渲染的，它里面的内容可以被 js 读取。  </p>
<p>template 的两种写法：  </p>
<ul>
<li>使用 script 标签（带有两个属性，一个是 <code>type=&quot;x-template&quot;</code>，一个是 id）   </li>
<li>使用 template 标签（一个 id 属性）  </li>
</ul>
<h3 id="data-属性"><a href="#data-属性" class="headerlink" title="data 属性"></a>data 属性</h3><p>data 属性：传入一个函数，并且该函数需要返回一个对象。  </p>
<p>在 Vue2.x 中，data 可以传入一个对象（虽然官方推荐是一个函数）；<br>在 Vue3.x 中，必须传入一个函数，否则浏览器就会报错。   </p>
<p>data 中返回的对象会被 <strong>Vue 的响应式系统劫持</strong>，之后<strong>对该对象的修改或访问</strong>，都会在劫持中被处理。   </p>
<h3 id="methods-属性"><a href="#methods-属性" class="headerlink" title="methods 属性"></a>methods 属性</h3><p>methods 属性：传入一个对象，在这个对象中可以定义很多方法。   </p>
<p>在该方法中，我们可以<strong>使用 this 关键字</strong>来直接访问到 data 中返回的对象的属性。   </p>
<p>官方文档中有这么一段话：  </p>
<blockquote>
<p>methods 中定义的函数，不能使用箭头函数，理由是<strong>箭头函数绑定了父级作用域的上下文</strong>，所以 this 将不会按照期望指向组件实例，<code>this.a</code> 将是 undefined。   </p>
</blockquote>
<p>问题：  </p>
<ul>
<li>为什么不能使用箭头函数？   </li>
<li>不使用箭头函数的情况下，this 到底指向的是什么？（可以作为一道面试题）  </li>
</ul>
<p>为什么不能使用箭头函数？   </p>
<p>如果使用箭头函数，这个 this 会指向 window，而不是 data 字段中对象返回的属性。   </p>
<pre><code class="hljs js">methods: &#123;
    btnClick: <span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);
    &#125;
&#125;</code></pre>

<p>为什么是 window 呢？  </p>
<p>这里涉及箭头函数使用 <strong>this 的查找规则</strong>，它会在自己的上层作用域中来查找 this；最终刚好找到 script 作用域中的 this，所以就是 window。  </p>
<p>箭头函数中的 this 没有做任何的绑定，它会往上层作用域找（一层一层找），最终到达顶层作用域，在 script 标签这一层，找到 window。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16470613709221.jpg" srcset="/img/loading.gif"></p>
<p>this 到底是如何查找和绑定的呢？   </p>
<h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><p>props、computed、watch、emits、setup 等等，也包含很多的生命周期函数。  </p>
<h2 id="Vue3-源码"><a href="#Vue3-源码" class="headerlink" title="Vue3 源码"></a>Vue3 源码</h2><p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/vuejs/core">https://github.com/vuejs/core</a>     </p>
<p>Vue 的源代码是通过 yarn 进行管理。  </p>
<p>终端需要安装 yarn，安装的命令：             </p>
<pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> yarn -g</code></pre>

<p>从 GitHub 仓库直接下载 Vue3 源码的压缩包，需要在终端中安装一些额外的东西： </p>
<p>进入 Vue3 源码解压后所在的路径，运行命令     </p>
<pre><code class="hljs cmake">yarn <span class="hljs-keyword">install</span></code></pre>

<p>调试代码的步骤：         </p>
<p>勘误：下面的那一行代码，位于 <code>package.json</code> 文件中。    </p>
<p>修改之后，运行命令 <code>yarn dev</code>，执行打包操作。       </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16470587663007.jpg" srcset="/img/loading.gif"></p>
<h2 id="Vue-基础-模板语法"><a href="#Vue-基础-模板语法" class="headerlink" title="Vue 基础 - 模板语法"></a>Vue 基础 - 模板语法</h2><h3 id="VS-Code-添加代码片段"><a href="#VS-Code-添加代码片段" class="headerlink" title="VS Code 添加代码片段"></a>VS Code 添加代码片段</h3><p>生成代码片段的在线工具：<a target="_blank" rel="noopener" href="https://snippet-generator.app/">https://snippet-generator.app/</a>  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16470753100267.jpg" srcset="/img/loading.gif"></p>
<p>使用方法：将写好的一整个 html 代码复制到左侧的窗口，就会自动生成代码片段。  </p>
<p>在顶部两个输入框分别输入「代码片段的名称」、「快速插入代码片段的命令」   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16470760844594.jpg" srcset="/img/loading.gif"></p>
<p>回到 VS Code，选择 首选项 &gt;&gt; 用户片段，搜索 <code>html.json</code>，将复制的代码片段粘贴到其他的大括号即可。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16470766359128.jpg" srcset="/img/loading.gif"></p>
<p>VS Code 开启自动保存的方法：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16470765239563.jpg" srcset="/img/loading.gif"></p>
<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>React 的开发模式（了解）：  </p>
<ul>
<li>React 使用的是 jsx，所以对应的代码都是编写的类似于 js 的一种语法；  </li>
<li>之后通过 Babel 将 jsx 编译成 React.createElement 函数调用。  </li>
</ul>
<p>jsx 语法：将 js 和 html 融合在一起的书写方式  </p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    
&#125;</code></pre>

<p>Vue 也支持 jsx 的开发模式：  </p>
<p>但多数情况下，使用<strong>基于 HTML 的模板语法</strong>；<br>在模板中，允许开发者以声明式的方式将 <strong>DOM</strong> 和<strong>底层组件实例的数据</strong>绑定在一起；<br>在底层的实现中，Vue 将模板编译成虚拟 DOM 渲染函数。      </p>
<p>下面是模板语法的例子：   </p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span> <span class="hljs-attr">v-bind</span> <span class="hljs-attr">v-once</span>&gt;</span>
    &#123;&#123;&#125;&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>

<h3 id="v-bind-的属性绑定"><a href="#v-bind-的属性绑定" class="headerlink" title="v-bind 的属性绑定"></a>v-bind 的属性绑定</h3><p>Vue2 template模板中只能有一个根元素，多个元素得包裹到一个div标签里；<br>Vue3 允许template模板中有多个根元素。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16471028032192.jpg" srcset="/img/loading.gif"></p>
<p>v-bind 绑定 class 有两种方式：   </p>
<ul>
<li>对象语法   </li>
<li>数组语法</li>
</ul>
<p>数组语法，数组中可以包含三元表达式，也可以包含对象。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16471394179750.jpg" srcset="/img/loading.gif"></p>
<p>v-bind 绑定 style 介绍   </p>
<p>v-bind:style 绑定 CSS 内联样式。   </p>
<p>CSS property 名可以用<strong>驼峰式</strong>(camelCase)或<strong>短横线分隔</strong>(kebab-case)来命名。      </p>
<p>绑定 class 有两种方式：     </p>
<ul>
<li>对象语法</li>
<li>数组语法   </li>
</ul>
<p>v-bind 动态绑定属性：绑定的属性名是不确定的，即用户自定义的属性名。   </p>
<p>写法：  </p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">PropertyName</span>]=<span class="hljs-string">&quot;PropertyValue&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
data() &#123;
<span class="javascript">    PropertyName: <span class="hljs-string">&quot;自定义的属性名&quot;</span></span>
<span class="javascript">    PropertyValue: <span class="hljs-string">&quot;属性值&quot;</span></span>
&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<p>v-bind 直接绑定一个对象：将一个对象的所有属性，绑定到 html 元素上的所有属性。        </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16471626696660.jpg" srcset="/img/loading.gif"></p>
<h3 id="v-on-绑定事件"><a href="#v-on-绑定事件" class="headerlink" title="v-on 绑定事件"></a>v-on 绑定事件</h3><p>前端开发中，需要经常和用户进行各种各样的<strong>交互</strong>，这时就必须监听用户发生的事件，比如：      </p>
<ul>
<li>点击</li>
<li>拖拽   </li>
<li>键盘事件等   </li>
</ul>
<p>在 Vue 中如何监听事件呢？使用 v-on 指令。   </p>
<p>v-on 可以绑定单个事件（单个函数），也可以绑定内联表达式(inline statement)和对象。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16471817367790.jpg" srcset="/img/loading.gif"></p>
<p>v-on 的参数传递   </p>
<p>v-on 绑定的函数需要传入多个对象的时候，event 对象前面要加多一个美元符号 $   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16471824562895.jpg" srcset="/img/loading.gif"></p>
<p>v-on 的修饰符  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16471826574713.jpg" srcset="/img/loading.gif"></p>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>Vue 提供了下面的指令来进行条件判断：   </p>
<ul>
<li>v-if   </li>
<li>v-else   </li>
<li>v-else-if   </li>
<li>v-show   </li>
</ul>
<h3 id="v-if-和-template-元素结合使用"><a href="#v-if-和-template-元素结合使用" class="headerlink" title="v-if 和 template 元素结合使用"></a>v-if 和 template 元素结合使用</h3><p>如果我们希望批量显示/隐藏多个元素，一般是在 template 中使用 div 元素进行包裹，但这样用于包裹的 div 最终会被渲染出来，增加了一个额外的 div 标签。    </p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>呵呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>呵呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>呵呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>

<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16471904822289.jpg" srcset="/img/loading.gif"></p>
<p>template 元素中可以嵌套 template 元素，它可以当做<strong>不可见的包裹元素</strong>，并且添加 v-if 指令，但是最终 template 不会被渲染出来，它有点类似于小程序中的 block。  </p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>呵呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>呵呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>呵呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre>

<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16471907753775.jpg" srcset="/img/loading.gif"></p>
<h3 id="v-show-和-v-if-的区别"><a href="#v-show-和-v-if-的区别" class="headerlink" title="v-show 和 v-if 的区别"></a>v-show 和 v-if 的区别</h3><p>用法上的区别：   </p>
<ul>
<li>v-show 不支持 template;   </li>
<li>v-show 不可以和 v-else 一起使用  </li>
</ul>
<p>本质上的区别：  </p>
<ul>
<li>v-show 元素无论是否需要显示到浏览器上，它的 DOM 实际都是有渲染的，只是通过 CSS 的 display 属性来进行切换；  </li>
<li>v-if 为 false 时，其对应的元素压根不会被渲染到 DOM 中。   </li>
</ul>
<p>开发中如何进行选择呢？  </p>
<ul>
<li>如果我们的元素需要在显示和隐藏之间频繁切换，那么使用 v-show（通过 CSS 来实现显示和隐藏间的切换，不会那么耗费性能）；      </li>
<li>如果不会频繁地发生切换，那么使用 v-if。  </li>
</ul>
<h3 id="v-for-列表渲染"><a href="#v-for-列表渲染" class="headerlink" title="v-for 列表渲染"></a>v-for 列表渲染</h3><p>v-for 支持遍历数组、对象和数字。  </p>
<p>v-for 遍历对象，支持有一二三个参数：  </p>
<ul>
<li>一个参数：value in object    </li>
<li>二个参数：(value, key) in object   </li>
<li>三个参数：(value, key, index) in object     </li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16473058251414.jpg" srcset="/img/loading.gif"></p>
<h3 id="v-for-中的-key-是什么？"><a href="#v-for-中的-key-是什么？" class="headerlink" title="v-for 中的 key 是什么？"></a>v-for 中的 key 是什么？</h3><p><strong>认识 VNode</strong>  </p>
<p>VNode 的全称是 Virtual Node，也就是虚拟节点。   </p>
<p>事实上，无论是组件还是元素，它们最终在 Vue 中表示出来的都是一个个 VNode；  </p>
<p>VNode 的本质是一个 JS 对象；  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16473642423596.jpg" srcset="/img/loading.gif"></p>
<p><strong>虚拟 DOM</strong></p>
<p>虚拟 DOM：多个 VNode 形成的树结构  </p>
<p>虚拟 DOM 最大的优点在于，可以做<strong>跨平台</strong>，可以在服务端渲染，可以做移动端    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16473643775064.jpg" srcset="/img/loading.gif"></p>
<p>Vue 中对于列表的更新是如何操作的呢？   </p>
<p>Vue 对于有 key 和没有 key 会调用两个不同的方法：  </p>
<p>有 key，就使用 patchKeyedChildren 方法；<br>没有 key，那么就使用 patchUnkeyedChildren 方法。   </p>
<h3 id="Vue-的-diff-算法"><a href="#Vue-的-diff-算法" class="headerlink" title="Vue 的 diff 算法"></a>Vue 的 diff 算法</h3><p>diff 算法用来比较新旧两个 VNode 列表。  </p>
<p>比较两个新旧节点的类型 type 和 key 是否相同。  </p>
<p>type 和 key 都一样的话，节点是不需要进行更新的。         </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16475309445882.jpg" srcset="/img/loading.gif"></p>
<p>如果新节点比旧节点多，会<strong>挂载</strong>(mount)新的节点。<br>如果旧节点比新节点多，会<strong>卸载/销毁</strong>(unmount)旧的、多余的节点。    </p>
<p>最后一步：新旧节点的排序比较混乱，尽可能地移动节点，移除新节点中没有的旧节点，新增旧节点中没有的新节点。  </p>
<p>尽可能在旧的节点列表里面，找到新的列表中对应的节点，比如新的节点里面有一个 h，就会尽可能地在旧节点里面找到 h。      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16475342142617.jpg" srcset="/img/loading.gif"></p>
<p>patch：  </p>
<p>如果 n1 非空，就进行更新操作；<br>如果 n1 为 null，就进行挂载操作。   </p>
<h3 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed 计算属性"></a>computed 计算属性</h3><p>对 data 中的数据进行复杂处理（对数据进行运算后再在模板中使用的情况），会用到计算属性。   </p>
<p>复杂 data 的处理方式    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16475799391071.jpg" srcset="/img/loading.gif"></p>
<p>计算属性的用法：  </p>
<ul>
<li>选项：computed   </li>
<li>类型：{[key: string]: Function | {get: Function, set: Function}}   </li>
</ul>
<p>key 的值是一个函数或者对象。  </p>
<p>插值语法(Mustache语法)的 3 个缺点：     </p>
<ul>
<li>模板中存在大量的复杂逻辑，不便于维护（模板中使用表达式的初衷是用于简单的计算）；          </li>
<li>当有多次一样的逻辑时，存在重复的代码；</li>
<li>多次使用的时候，很多运算需要多次执行，<strong>没有缓存</strong></li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16476228150335.jpg" srcset="/img/loading.gif"></p>
<p>计算属性的缓存：  </p>
<ul>
<li>计算属性会基于它们的依赖关系进行缓存</li>
<li>在数据不发生变化时，计算属性是不需要重新计算的    </li>
<li>但如果依赖的<strong>数据发生变化</strong>，在使用时，计算属性依然会重新进行计算   </li>
</ul>
<h3 id="计算属性的-setter-和-getter-方法"><a href="#计算属性的-setter-和-getter-方法" class="headerlink" title="计算属性的 setter 和 getter 方法"></a>计算属性的 setter 和 getter 方法</h3><p>计算属性的完整写法，应该是包含 setter 和 getter 方法的，需要写成<strong>对象</strong>的形式，但我们一般只用到 getter 方法，所以就会写成<strong>函数</strong>的形式，这个函数就是 getter 方法。  </p>
<p>老师上课的笔记：计算属性在大多数情况下，只需要一个 getter 方法即可，所以我们会<strong>将计算属性直接写成一个函数</strong>。     </p>
<p>下面是计算属性的完整写法：  </p>
<p>给计算属性传参（赋值）的时候，会调用计算属性的 setter 方法。       </p>
<pre><code class="hljs js">computed: &#123;
    fullName: &#123;
        set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) </span>&#123;
            <span class="hljs-built_in">console</span>.log(newValue);
        &#125;,
        get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.lastName
        &#125;
    &#125;
&#125;</code></pre>

<p>下面是计算属性的简略写法（只用到 getter 方法）：    </p>
<pre><code class="hljs js">computed: &#123;
    fullName() &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.lastName      
    &#125;
&#125;</code></pre>

<h3 id="认识侦听器-watch"><a href="#认识侦听器-watch" class="headerlink" title="认识侦听器 watch"></a>认识侦听器 watch</h3><p>在某些情况下，我们希望在<strong>代码逻辑</strong>中监听某个数据的变化，这个时候就需要用侦听器 watch 来完成了。     </p>
<p>侦听器的用法：  </p>
<ul>
<li>选项：watch   </li>
<li>类型：{[key:string]: string|Function|Object|Array}   </li>
</ul>
<p>watch 后面跟一个对象，对象里面是一个键值对，值可以是函数，也可以是字符串/对象/数组。    </p>
<p>侦听器的使用场景：侦听当 data 里面的数据发生变化时，想要进行一些<strong>逻辑处理</strong>（JavaScript，例如向服务器发送网络请求）    </p>
<p>watch 是 Vue 实例中的一个 option。   </p>
<p>watch 中的 question 侦听 data 中的属性的名称。    </p>
<p>watch 可以调用 methods 中定义的函数。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16476678949655.jpg" srcset="/img/loading.gif"></p>
<p>上图中的 <code>你问题$&#123;this.question&#125;的回答是 哈哈哈哈哈哈</code> 是 ES6 中的模板字符串语法，可以很方便地进行字符串的拼接。   </p>
<p><strong>字符串拼接表达式</strong>的时候，可以使用 ${} 来拼接。   </p>
<h3 id="侦听器的配置选项"><a href="#侦听器的配置选项" class="headerlink" title="侦听器的配置选项"></a>侦听器的配置选项</h3><ul>
<li>深度侦听</li>
<li>立即执行   </li>
</ul>
<p>下图的 info 是一个来自 data 中的对象，当对象里的一个键值对发生变化、而非整个对象发生变化时，watch 在默认情况下，无法监听到内部属性的变化。  </p>
<p>此时就需要给 watch 配置一个 <strong>deep</strong> 选项，实现深度侦听。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16476783824194.jpg" srcset="/img/loading.gif"></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16476789743188.jpg" srcset="/img/loading.gif"></p>
<h3 id="侦听器-watch-的其他方式"><a href="#侦听器-watch-的其他方式" class="headerlink" title="侦听器 watch 的其他方式"></a>侦听器 watch 的其他方式</h3><p>侦听器的其他写法：  </p>
<p>使用 $watch 的 API，需要配合<strong>生命周期函数</strong>一起使用         </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16476795876487.jpg" srcset="/img/loading.gif"></p>
<p>生命周期函数与实例中的 data()、methods 选项处于同一层级。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16476805015043.jpg" srcset="/img/loading.gif"></p>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p><strong>浅拷贝</strong>在堆内存中的表现：  </p>
<p>浅拷贝只会拷贝第一层，如果内部嵌套了对象，还是会指向对象原来的内存地址。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16476928211960.jpg" srcset="/img/loading.gif"></p>
<p>那如果要实现深拷贝，该怎么办呢？  </p>
<p>需要借助 JSON 的两个方法：   </p>
<ul>
<li>stringify()：先把对象转换成字符串     </li>
<li>parse()：转成字符串之后，再对字符串进行还原，就会在内存中生成一个新的对象    </li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> info = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;phh&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span>, <span class="hljs-attr">friend</span>: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;angola peng&#x27;</span>&#125; &#125;;   

<span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(info));</code></pre>

<p>经过上面两步，就可以实现深拷贝，生成一个新的对象 obj。   </p>
<h2 id="Vue3-的表单"><a href="#Vue3-的表单" class="headerlink" title="Vue3 的表单"></a>Vue3 的表单</h2><p>v-model 本质上是语法糖。  </p>
<p>双向绑定：可以将 data 中的值绑定到 input(表单)的 value 属性上面，同时当 input 的 value 发生变化时，会将最新的值更新到 data 中。 </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16477028248176.jpg" srcset="/img/loading.gif"></p>
<p><strong>v-model 修饰符 lazy</strong>  </p>
<p>修饰符 lazy 的本质：将 v-model 内部绑定的 input 事件切换为 <strong>change 事件</strong>，只有在提交(比如按下回车键)时才会触发。        </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16477392862009.jpg" srcset="/img/loading.gif"></p>
<p>v-model 修饰符 number：将输入的文本转换为数字类型<br>v-model 修饰符 trim：去除用户输入的 value 前后的空格    </p>
<h2 id="Vue-组件化开发"><a href="#Vue-组件化开发" class="headerlink" title="Vue 组件化开发"></a>Vue 组件化开发</h2><p>组件化开发的思想：将页面拆分成一个个小的功能块，之后像<strong>搭积木</strong>一样，把组件组装到一起。     </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16477445942339.jpg" srcset="/img/loading.gif"></p>
<p>现在整个大前端开发都是组件化的天下，无论是三大框架，还是跨平台方案的 Flutter，甚至是移动端都在转向组件化开发，包括小程序的开发也是采用组件化开发的思想。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16477449433308.jpg" srcset="/img/loading.gif"></p>
<h3 id="注册组件的方式"><a href="#注册组件的方式" class="headerlink" title="注册组件的方式"></a>注册组件的方式</h3><p>注册组件分成两种：  </p>
<ul>
<li>全局组件：在任何其他的组件中都可以使用的组件   </li>
<li>局部组件：只有在注册的组件中才能使用的组件   </li>
</ul>
<p><strong>注册全局组件</strong>   </p>
<p>全局组件：注册的组件可以在任何的组件模板中使用。  </p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> app = Vue.createApp(App);

<span class="hljs-comment">// 伪代码</span>
<span class="hljs-comment">// app.component(&quot;组件名称&quot;, 组件对象)</span>

app.component(<span class="hljs-string">&quot;component-a&quot;</span>, &#123;
    template: <span class="hljs-string">&#x27;#component-a&#x27;</span>,
    data() &#123;
        <span class="hljs-keyword">return</span> &#123;
            message: <span class="hljs-string">&#x27;hello world&#x27;</span>
        &#125;
    &#125;
&#125;)</code></pre>

<p>实际开发中一般不推荐使用全局组件。   </p>
<p><strong>全局组件的逻辑</strong></p>
<p>组件本身也可以有自己的代码逻辑：比如 data、computed、methods 等。   </p>
<p><strong>组件的名称</strong>   </p>
<p>通过 <code>app.component</code> 注册组件时，第一个参数是<strong>组件的名称</strong>，定义组件名的方式有两种：   </p>
<p>方式一：使用 kebab-case（短横线分隔符）   </p>
<pre><code class="hljs js">app.component(<span class="hljs-string">&#x27;my-component-name&#x27;</span>, &#123;
    <span class="hljs-comment">/* … */</span>
&#125;)</code></pre>

<p>在引用这个组件时，也必须使用 kebab-case，例如 <code>&lt;my-component-name&gt;</code>      </p>
<p>方式二：使用 PascalCase（驼峰标识符）   </p>
<pre><code class="hljs js">app.component(<span class="hljs-string">&#x27;ComponentName&#x27;</span>, &#123;
    <span class="hljs-comment">/* … */</span>
&#125;)</code></pre>

<p>组件命名一般采用<strong>大驼峰</strong>，首字母必须是大写。        </p>
<p>采用驼峰命名的方式，在模板中引用这个组件时，有两种写法：  </p>
<ul>
<li><code>&lt;component-name&gt;</code>   </li>
<li><code>&lt;ComponentName&gt;</code>（实际开发中<strong>不推荐使用</strong>这种）        </li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16477495715671.jpg" srcset="/img/loading.gif"></p>
<p><strong>注册局部组件</strong>   </p>
<p>局部组件：通过 <strong>components 属性选项</strong>来注册，这个选项与之前的 data、methods、computed 处于同一层级。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16477501396196.jpg" srcset="/img/loading.gif"></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16477576075152.jpg" srcset="/img/loading.gif"></p>
<h2 id="Vue-的开发模式"><a href="#Vue-的开发模式" class="headerlink" title="Vue 的开发模式"></a>Vue 的开发模式</h2><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16477577826684.jpg" srcset="/img/loading.gif"></p>
<p>单文件组件的后缀为 <code>.vue</code>，浏览器无法识别，因此还需要经过构建、打包的环节，借助 Webpack 或 Vite 将 <code>.vue</code> 转换为普通的 js 文件。   </p>
<pre><code class="hljs vue">&lt;template&gt;

&lt;&#x2F;template&gt;

&lt;script&gt;

&lt;&#x2F;script&gt;

&lt;style&gt;

&lt;&#x2F;style&gt;</code></pre>

<h3 id="单文件的特点"><a href="#单文件的特点" class="headerlink" title="单文件的特点"></a>单文件的特点</h3><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16477582245705.jpg" srcset="/img/loading.gif"></p>
<h3 id="如何支持单文件组件"><a href="#如何支持单文件组件" class="headerlink" title="如何支持单文件组件"></a>如何支持单文件组件</h3><p>想要使用这一单文件组件的 <code>.vue</code> 文件，比较常见的两种方式：   </p>
<ul>
<li>方式一：使用 <strong>Vue CLI</strong> 来创建项目，项目会默认帮我们配置好所有的配置选项，可以在其中直接使用 <code>.vue</code> 文件（<strong>脚手架本质上也是基于 Webpack 的</strong>）  </li>
<li>方式二：自己使用 <strong>Webpack</strong> 或 rollup 或 Vite 这类打包工具，对其进行打包处理    </li>
</ul>
<p>最终，无论是后期做项目，还是在公司进行开发，通常都会采用 Vue CLI 的方式来完成。    </p>
<p>在学习阶段，为了更好地理解 Vue CLI 打包项目的过程，会先讲解一部分 Webpack 的知识。   </p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>Webpack 的官方文档：<a target="_blank" rel="noopener" href="https://webpack.js.org/">https://webpack.js.org</a><br>Webpack 的中文官方文档：<a target="_blank" rel="noopener" href="https://webpack.docschina.org/">https://webpack.docschina.org</a>    </p>
<p>Webpack 依赖 Node 环境，因此需要先安装 nodejs。    </p>
<p>下面的内容基于最新的 Webpack 5。  </p>
<h3 id="认识-Webpack"><a href="#认识-Webpack" class="headerlink" title="认识 Webpack"></a>认识 Webpack</h3><p>三大框架的脚手架都是基于 Webpack 的。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16477612953301.jpg" srcset="/img/loading.gif"></p>
<p>Webpack is a static module bundler for modern JavaScript applications.        </p>
<p>Webpack 是一个静态的<strong>模块化</strong>打包工具。   </p>
<p>Webpack 默认支持各种模块化开发，包含 ES Module、CommonJS、AMD 等。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16477616392501.jpg" srcset="/img/loading.gif"></p>
<h3 id="Vue-项目加载的文件有哪些？"><a href="#Vue-项目加载的文件有哪些？" class="headerlink" title="Vue 项目加载的文件有哪些？"></a>Vue 项目加载的文件有哪些？</h3><p>Webpack 会对哪些文件进行打包？  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16477618774866.jpg" srcset="/img/loading.gif"></p>
<h3 id="Webpack-的安装"><a href="#Webpack-的安装" class="headerlink" title="Webpack 的安装"></a>Webpack 的安装</h3><p>Webpack 的安装目前分为两个：<strong>webpack</strong>、<strong>webpack-cli</strong>     </p>
<p>当我们在命令行中使用 webpack，并且传入一些参数时，就需要用到 <code>webpack-cli</code>。     </p>
<p>webpack 在执行时是依赖 webpack-cli 的，如果没有安装就会报错。   </p>
<p>webpack 和 webpack-cli 的关系：    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16478785840276.jpg" srcset="/img/loading.gif"></p>
<p>全局安装 webpack 和 webpack-cli：  </p>
<pre><code class="hljs avrasm">npm install webpack webpack-<span class="hljs-keyword">cli</span> -g</code></pre>

<p>老师视频中使用的版本：   </p>
<p>webpack 5.37.1<br>webpack-cli 4.7.0   </p>
<p>在实际开发中，很少会用全局的 webpack 来打包项目，一般都会针对项目单独安装一个 webpack 版本，这就需要用到局部 webpack。  </p>
<p>项目中会包含多个包(package)，使用 <code>package.json</code> 来管理这些包。  </p>
<p>生成 <code>package.json</code> 文件的方法：   </p>
<p>打开终端，输入 <code>npm init</code>，按下回车，需要给包起一个名字，接下去一路回车，就会生成 <code>package.json</code> 文件。   </p>
<p>这种生成 <code>package.json</code> 文件的方法，适用于文件包含有<strong>中文名称</strong>的情况。   </p>
<p>另外一个生成 <code>package.json</code> 文件的方式： </p>
<pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init -y</code></pre>

<p>-y 表示后面所有的选项都是 yes，可以快速创建 <code>package.json</code> 文件。   </p>
<p>局部安装的 Webpack 分为两类：   </p>
<ul>
<li>开发阶段依赖的 Webpack：开发者开发时使用的        </li>
<li>生产阶段依赖的 Webpack：项目正式上线后，面向用户的            </li>
</ul>
<p>在项目文件夹中直接运行 <code>npm install webpack webpack-cli</code>，默认安装生产依赖的 webpack（面向用户的）。    </p>
<p>开发时依赖的 Webpack 的安装命令：   </p>
<pre><code class="hljs q">npm install webpack webpack-cli --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre>

<p>上面的安装命令也可以简写成：       </p>
<pre><code class="hljs avrasm">npm install webpack webpack-<span class="hljs-keyword">cli</span> -D</code></pre>

<p>运行局部 Webpack 的命令：  </p>
<pre><code class="hljs ebnf"><span class="hljs-attribute">npx webpack</span></code></pre>

<p>Webpack 对项目进行打包，默认会去找 src 文件夹下面的 <code>index.js</code> 文件，这被称为<strong>入口文件</strong>。  </p>
<p>如果把 <code>index.js</code> 文件命名为其他的名字，例如 <code>main.js</code>，在运行打包命令的时候，要带上<strong>额外的参数</strong>，配置 <code>main.js</code>为入口文件：     </p>
<pre><code class="hljs awk">npx webpack --entry .<span class="hljs-regexp">/src/m</span>ain.js</code></pre>

<h3 id="webpack-配置文件"><a href="#webpack-配置文件" class="headerlink" title="webpack 配置文件"></a>webpack 配置文件</h3><p>项目文件中单独创建一个 <code>webpack.config.js</code>文件，来对 webpack 进行配置：   </p>
<p>出口 output 的 path 属性，它的值应该为<strong>绝对路径</strong>，即完整的文件路径。      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16479085335494.jpg" srcset="/img/loading.gif"></p>
<p>但这个绝对路径比较长，我们通常会用 Node 中的 path 模块，来简化绝对路径的写法。   </p>
<p>调用 path 模块的 resolve 方法，对两个路径进行拼接：   </p>
<pre><code class="hljs less"><span class="hljs-selector-tag">path</span><span class="hljs-selector-class">.resolve</span>(__dirname, <span class="hljs-string">&quot;./build&quot;</span>)</code></pre>

<p><code>__dirname</code> 是 <code>webpack.config.js</code> 文件所在的绝对路径，<code>./build</code>是打包后的文件存放位置的相对路径。   </p>
<p>将这两个路径拼接后，就可以找到打包文件所在的位置啦。   </p>
<p>配置文件的名称多数情况下为 <code>webpack.config.js</code>，如果你执意要更改文件的名称，例如更改为 <code>why.config.js</code>，需要在 <code>package.json</code>中作相应的调整，build 属性后面需要配置额外的参数：     </p>
<pre><code class="hljs 1c"><span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --config why.config.js&quot;</span></code></pre>

<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16479958252520.jpg" srcset="/img/loading.gif"></p>
<p>在 <code>package.json</code> 文件中配置好 webpack 和 webpack-cli 的依赖后，在终端输入 <code>npm install</code>，安装的就是局部的 webpack。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16480509148257.jpg" srcset="/img/loading.gif"></p>
<h3 id="Webpack-打包的依赖关系图"><a href="#Webpack-打包的依赖关系图" class="headerlink" title="Webpack 打包的依赖关系图"></a>Webpack 打包的依赖关系图</h3><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16480531421554.jpg" srcset="/img/loading.gif"></p>
<h3 id="css-loader-的使用"><a href="#css-loader-的使用" class="headerlink" title="css-loader 的使用"></a>css-loader 的使用</h3><p>Webpack 需要 loader 来加载 CSS 文件。   </p>
<p>安装 css-loader：  </p>
<pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> css-loader -D</code></pre>

<p>loader 是什么呢？  </p>
<ul>
<li>loader 可以用于对模块的源代码进行转换   </li>
<li>我们可以<strong>将 css 文件也看成是一个模块</strong>，我们是通过 import 来加载这个 css 模块的    </li>
<li>在加载这个 css 模块时，Webpack 其实并不知道如何对其进行加载，必须制定对应的 loader 来完成这个功能   </li>
</ul>
<p><strong>loader 的配置</strong>    </p>
<p>css-loader 加载 css 文件的 3 种方式：  </p>
<ul>
<li>内联方式   </li>
<li>CLI 方式（Webpack5 中不再使用）    </li>
<li>配置方式（多采用这一种）</li>
</ul>
<p>内联方式：使用较少，因为不方便管理。</p>
<p>在引入的 css 样式前加上使用的 loader，并且使用英文感叹号分割：  </p>
<pre><code class="hljs xl"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;css-loader!../css/style.css&quot;</span></code></pre>

<p><strong>loader 的配置方式：</strong>    </p>
<p>在 <code>webpack.js.config</code> 中写明我们用到的 loader。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16481312600912.jpg" srcset="/img/loading.gif"></p>
<h3 id="认识-style-loader"><a href="#认识-style-loader" class="headerlink" title="认识 style-loader"></a>认识 style-loader</h3><p>前面的 css-loader 只负责将 <code>.css</code> 文件进行解析，并不会将解析之后的 css 插入到页面中。    </p>
<p>如果想要把完成插入 style 的操作（将解析后的 css 插入到 html 中的 style 标签），还需要用到另外一个 loader——<strong>style-loader</strong>。   </p>
<p>安装 style-loader：  </p>
<pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> <span class="hljs-keyword">style</span>-loader -D</code></pre>

<p>两个 loader 的执行顺序：先执行 css-loader，再执行 style-loader。   </p>
<p>但在 use 数组中，它是从后往前执行 loader 的，因此先执行的 css-loader 要写在后面。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16481343531644.jpg" srcset="/img/loading.gif"></p>
<h3 id="如何处理-less-文件"><a href="#如何处理-less-文件" class="headerlink" title="如何处理 less 文件"></a>如何处理 less 文件</h3><p>less 文件要先转换为普通的 CSS 文件，转换需要用到一个工具 less compiler，简称 lessc。  </p>
<p>lessc 与 Webpack 没有任何关系，它是一个独立的工具。   </p>
<p>局部安装 lessc：   </p>
<pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> <span class="hljs-keyword">less</span> -D</code></pre>

<p>将 lessc 工具与 Webpack 关联起来，需要安装 less-loader。实际上 less-loader 依赖 lessc 工具。   </p>
<p>局部安装 less-loader：  </p>
<pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> <span class="hljs-keyword">less</span>-loader -D</code></pre>

<p>之后同样需要在 <code>webpack.config.js</code> 文件中进行配置，处理 less 文件需要用到 3 个 loader：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16481357156386.jpg" srcset="/img/loading.gif"></p>
<h3 id="认识-PostCSS-工具"><a href="#认识-PostCSS-工具" class="headerlink" title="认识 PostCSS 工具"></a>认识 PostCSS 工具</h3><p>PostCSS 是一个<strong>通过 JS 来转换 css 样式</strong>的工具；<br>这个工具可以帮助我们进行一些 CSS 的转换和适配，比如自动添加**浏览器前缀(user-select)**、css 样式的重置；<br>但是实现这些功能，我们需要借助 PostCSS 对应的插件。   </p>
<p>使用 PostCSS 的两个步骤：   </p>
<ol>
<li>查找 PostCSS 在构建工具中的扩展，比如 webpack 中的 postcss-loader    </li>
<li>选择可以添加你需要的 PostCSS 相关的插件，例如 autoprefixer 插件       </li>
</ol>
<p>PostCSS 工具与 Webpack 无关，可以独立使用。   </p>
<p>安装 PostCSS：  </p>
<pre><code class="hljs avrasm">npm install postcss postcss-<span class="hljs-keyword">cli</span> -D</code></pre>

<p>安装 autoprefixer 插件：  </p>
<pre><code class="hljs angelscript">npm install <span class="hljs-built_in">auto</span>prefixer -D</code></pre>

<p>在 Webpack 中使用 PostCSS，还需要安装 postcss-loader：   </p>
<pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> postcss-loader -D</code></pre>

<p><code>webpack.config.js</code> 中配置 postcss-loader 时，需要额外配置使用到的 autoprefixer 插件：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16481376464344.jpg" srcset="/img/loading.gif"></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16481376630475.jpg" srcset="/img/loading.gif"></p>
<p>另外一个 postcss 插件：postcss-preset-env  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16481378414151.jpg" srcset="/img/loading.gif"></p>
<p>现代的 CSS 特性：<strong>最新的 CSS 中表示颜色的十六进制可以有 8 位，例如 #12345678</strong>，而不是只能有 6 位——#123456。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16481382257857.jpg" srcset="/img/loading.gif"></p>
<p>局部安装插件：   </p>
<pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> postcss-preset-env -D</code></pre>

<h2 id="Webpack-打包其他资源"><a href="#Webpack-打包其他资源" class="headerlink" title="Webpack 打包其他资源"></a>Webpack 打包其他资源</h2><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p>加载图片这种资源，需要使用 file-loader。  </p>
<p>引用图片的两种方式：   </p>
<ul>
<li>一种是给 div 设置图片背景，在 CSS 中使用 <code>background-image: url()</code>    </li>
<li>一种是在 img 元素的 src 属性引入图片         </li>
</ul>
<p>在 CSS 中使用 <code>background-image: url()</code> 的配置方式：    </p>
<p>Webpack5 中使用 file-loader 打包图片，需要添加额外的配置：  </p>
<ul>
<li>options 中关闭 esModule 模块（file-loader 默认使用 ES6 模块解析），启用 file-loader 的 CommonJS 模块（不配置这个，html 文件中图片路径不对）   </li>
<li>后面要加多一个 type，否则会打包生成两张图片      </li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482304113249.jpg" srcset="/img/loading.gif"></p>
<p>下图来自 Stackoverflow<br><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482304845203.jpg" srcset="/img/loading.gif"></p>
<p>在 img 元素的 src 属性引入图片的配置方法：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482322835534.jpg" srcset="/img/loading.gif"></p>
<p>在 template 中引用图片，图片会通过 vue-loader 进行编译。   </p>
<h3 id="图片打包后生成文件的命名"><a href="#图片打包后生成文件的命名" class="headerlink" title="图片打包后生成文件的命名"></a>图片打包后生成文件的命名</h3><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482325495717.jpg" srcset="/img/loading.gif"><br>上图有个错别字，截图 ▶ 截取。   </p>
<p>file-loader 打包后的图片会放在 build(dist) 文件夹中，如果想把打包后的文件都归集到 img 文件中，需要给 file-loader 配置 <strong>outputPath</strong> 字段。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482605312293.jpg" srcset="/img/loading.gif"></p>
<p>对打包后的图片进行命名       </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482613068661.jpg" srcset="/img/loading.gif"></p>
<p>实际开发中，可以把 outputPath 去掉，与 name 字段进行合并，同时指定保存的文件夹和打包生成的文件名。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482622582028.jpg" srcset="/img/loading.gif"></p>
<h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p>url-loader 和 file-loader 的工作方式是相似的，但是可以将较小的文件，转成 base64 的 URI。  </p>
<p>服务器「高并发」，经常会对<strong>小的图片</strong>进行处理，减少浏览器向服务器发送请求的次数：   </p>
<ul>
<li>精灵图：将多张小的图片合并为一张图   </li>
<li>字体图标：iconfont，矢量图    </li>
<li>对小的图片进行编码：编码成 base64 的 URI   </li>
</ul>
<p>安装 url-loader：  </p>
<pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> <span class="hljs-keyword">url</span>-loader -D</code></pre>

<p>url-loader 和 file-loader 的区别：   </p>
<ul>
<li>想把全部图片打包，就用 file-loader</li>
<li>想把部分小图片使用 base64 编码，就用 url-loader   </li>
</ul>
<p>url-loader 配置时，需要增加一个字段 limit，划定使用 base64 编码的界限。  </p>
<p>如下图，当图片小于 100kb 时，使用 base64 进行编码。     </p>
<p> <img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482638055212.jpg" srcset="/img/loading.gif"></p>
<h3 id="认识-asset-module-type"><a href="#认识-asset-module-type" class="headerlink" title="认识 asset module type"></a>认识 asset module type</h3><p>在 Webpack5 之前，加载资源需要使用一些 loader，比如 <strong>raw-loader、url-loader、file-loader</strong>；   </p>
<p>从 Webpack5 开始，我们可以直接使用**资源模块类型(asset module type)**，来替代上面的这些 loader。    </p>
<p><strong>使用 asset module type，不需要安装任何模块</strong>，可以直接使用。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482640706763.jpg" srcset="/img/loading.gif"></p>
<p><code>type: &quot;asset&quot;</code> 可以像之前的 url-loader 一样，对小于 100kb 的图片使用 base64 编码，不过它的配置方式比较特殊：    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482648072239.jpg" srcset="/img/loading.gif"></p>
<p>配置打包后的路径和文件名，使用字段 generator，需要注意的是，<strong>filename 中的扩展名 [ext] 前面不需要加英文句号</strong>。      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482651041691.jpg" srcset="/img/loading.gif"></p>
<h3 id="加载字体文件"><a href="#加载字体文件" class="headerlink" title="加载字体文件"></a>加载字体文件</h3><p>在 src 文件中放入字体文件夹 font，里面包含 3 个字体文件和 2 个 css 文件。</p>
<p>接着在 <code>element.js</code> 中导入 <code>iconfont.css</code> 文件。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482736683933.jpg" srcset="/img/loading.gif"></p>
<p>加载字体文件有两种方式：  </p>
<ul>
<li>使用 file-loader 模块（参考加载图片的写法）  </li>
<li>使用 Webpack5 内置的资源模块类型(asset module type)     </li>
</ul>
<p>在 <code>webpack.config.js</code> 中添加配置：  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482742769686.jpg" srcset="/img/loading.gif"></p>
<h2 id="Webpack-插件"><a href="#Webpack-插件" class="headerlink" title="Webpack 插件"></a>Webpack 插件</h2><p>Webpack 的另一个核心是 Plugin。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482747955742.jpg" srcset="/img/loading.gif"></p>
<h3 id="CleanWebpackPlugin"><a href="#CleanWebpackPlugin" class="headerlink" title="CleanWebpackPlugin"></a>CleanWebpackPlugin</h3><p>前面每次修改了一些配置，重新打包时，都需要手动删除  build 文件夹。  </p>
<p>我们可以借助一个插件 CleanWebpackPlugin，来帮我们自动删除之前打包的文件。   </p>
<p>安装插件：  </p>
<pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> clean-webpack-<span class="hljs-keyword">plugin</span> -D</code></pre>

<p>安装插件之后，还需要在 <code>webpack.config.js</code> 中导入：   </p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;clean-webpack-plugin&quot;</span>);</code></pre>

<p>上面的 CleanWebpackPlugin 是一个类。  </p>
<p>导入后，在 <code>module.exports</code> 中使用插件：  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482756531403.jpg" srcset="/img/loading.gif"></p>
<p>每次运行 <code>npm run build</code> 时，插件会自动删除之前打包生成的 build 文件夹，生成新的 build。  </p>
<h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>之前写的代码，html 文件都是没有打包到 build 文件夹中，如果要对放在根目录下的 html 进行打包，需要用到另外一个插件——HtmlWebpackPlugin。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482759272641.jpg" srcset="/img/loading.gif"></p>
<p>配置 HtmlWebpackPlugin 插件：    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482762310525.jpg" srcset="/img/loading.gif"></p>
<p>配置好插件后，我们可以把之前放在根目录下的 <code>index.html</code> 文件删除，因为这个插件会在打包后的 build 文件中生成一个 <code>index.html</code>。 </p>
<p>自动生成的 <code>index.html</code> 文件，是根据 ejs 的一个模板来生成的。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482768532420.jpg" srcset="/img/loading.gif"></p>
<p>自定义 HTML 模板    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482769331352.jpg" srcset="/img/loading.gif"></p>
<p>可以在根目录下创建一个 public 文件夹，存放自定义的 html 模板。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482778952822.jpg" srcset="/img/loading.gif"></p>
<p>在 <code>webpack.config.js</code> 的 HtmlWebpackPlugin 插件传入我们自定义的 html 模板：    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482779270604.jpg" srcset="/img/loading.gif"></p>
<p>之后 Webpack 进行打包时，就会以自定义的 html 模板为基础进行打包，而不是使用 HtmlWebpackPlugin 插件的 ejs 模板。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482770468083.jpg" srcset="/img/loading.gif"></p>
<h3 id="CopyWebpackPlugin"><a href="#CopyWebpackPlugin" class="headerlink" title="CopyWebpackPlugin"></a>CopyWebpackPlugin</h3><p>放在 public 文件夹下的文件，例如 <code>favicon.ico</code>，一般在打包时会直接复制到 build 文件夹中。</p>
<p>要想实现<strong>自动复制（文件拷贝）</strong>，需要借助插件 CopyWebpackPlugin。      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482864720518.jpg" srcset="/img/loading.gif"></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482807983680.jpg" srcset="/img/loading.gif"></p>
<p>注意：直接使用最新版的 CopyWebpackPlugin 插件，打包时会报错，建议使用视频中 coderwhy 老师用到的 9.0.0 版本。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482850581542.jpg" srcset="/img/loading.gif"></p>
<p>安装 CopyWebpackPlugin 插件：  </p>
<pre><code class="hljs angelscript">npm install copy-webpack-<span class="hljs-symbol">plugin@</span><span class="hljs-number">9.0</span><span class="hljs-number">.0</span> -D</code></pre>

<p>插件配置：  </p>
<p>在 <code>webpack.config.js</code> 中引入插件：  </p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;copy-webpack-plugin&#x27;</span>);</code></pre>

<p>接着在下面的插件中 new 一个插件：  </p>
<p>把 <code>favicon.ico</code> 从 public 复制到 build 文件夹，并忽略 public 文件夹中所有叫 <code>index.html</code> 的文件。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482853972994.jpg" srcset="/img/loading.gif"></p>
<h3 id="Webpack-的-Mode-配置"><a href="#Webpack-的-Mode-配置" class="headerlink" title="Webpack 的 Mode 配置"></a>Webpack 的 Mode 配置</h3><p>不设置的话，默认是生产模式。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482880965326.jpg" srcset="/img/loading.gif"></p>
<p>当我们把 mode 设置为 development(开发模式)，Webpack 会自动配置下面一大堆选项。      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482881581774.jpg" srcset="/img/loading.gif"></p>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>Webpack 打包 js 和 <code>.vue</code> 文件。   </p>
<p>Babel 是一个工具链，可以将 ES6+ 的代码转换为向后兼容的 JS。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482911713645.jpg" srcset="/img/loading.gif"></p>
<p>安装 babel：  </p>
<pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @babel/core @babel/cli -D</code></pre>

<p>一个小例子：将使用 ES6 语法写的 <code>demo.js</code> 转换成 ES5 语法   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482939122966.jpg" srcset="/img/loading.gif"></p>
<p>局部安装的 babel，在终端调用的时候，要用 npx 命令：   </p>
<pre><code class="hljs mipsasm">npx <span class="hljs-keyword">babel </span>demo.<span class="hljs-keyword">js </span>--out-<span class="hljs-keyword">dir </span><span class="hljs-keyword">dist </span></code></pre>

<p><code>--out-dir</code> 指定文件输出的目录，输出到 dist 文件夹。   </p>
<p>如果想直接指定输出的文件名，可以改写一下命令：  </p>
<pre><code class="hljs x86asm">npx babel demo<span class="hljs-number">.</span><span class="hljs-keyword">js</span> --<span class="hljs-keyword">out</span>-file <span class="hljs-keyword">test</span><span class="hljs-number">.</span><span class="hljs-keyword">js</span></code></pre>

<p>这样输出的 <code>test.js</code> 文件就和 <code>demo.js</code> 在同一个路径下。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16482930906558.jpg" srcset="/img/loading.gif"></p>
<p>运行 babel 时，转换箭头函数，就需要配置用到的插件：  </p>
<pre><code class="hljs stata">npx babel demo.js --<span class="hljs-keyword">out</span>-<span class="hljs-keyword">file</span> <span class="hljs-keyword">test</span>.js --plugins=@babel/<span class="hljs-keyword">plugin</span>-transform-arrow-functions</code></pre>

<p>babel 转换 ES6 块级作用域插件：transform-block-scoping   </p>
<p>ES6 块级作用域，指的是 ES6 中的关键字 const、let。      </p>
<p>安装插件：  </p>
<pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> @babel/<span class="hljs-keyword">plugin</span>-transform-<span class="hljs-keyword">block</span>-scoping -D</code></pre>

<p>在命令行中同时使用两个插件的写法，使用逗号进行分割：      </p>
<pre><code class="hljs stata">npx babel demo.js --<span class="hljs-keyword">out</span>-<span class="hljs-keyword">file</span> <span class="hljs-keyword">test</span>.js --plugins=@babel/<span class="hljs-keyword">plugin</span>-transform-arrow-functions,@babel/<span class="hljs-keyword">plugin</span>-transform-block-scoping</code></pre>

<h3 id="Babel-的预设-preset"><a href="#Babel-的预设-preset" class="headerlink" title="Babel 的预设 preset"></a>Babel 的预设 preset</h3><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483088835337.jpg" srcset="/img/loading.gif"></p>
<p>安装 Babel 预设： </p>
<pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @babel/preset-env -D</code></pre>

<p>使用预设：  </p>
<pre><code class="hljs mipsasm">npx <span class="hljs-keyword">babel </span>demo.<span class="hljs-keyword">js </span>--out-file test.<span class="hljs-keyword">js </span>--presets=@<span class="hljs-keyword">babel/preset-env </span></code></pre>

<p>上面的命令就可以取代前面长长的命令啦，也不需要去安装两个插件，来分别实现 箭头函数、ES6 块级作用域 的转换。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483165117803.jpg" srcset="/img/loading.gif"></p>
<h3 id="Babel-编译器执行原理（了解）"><a href="#Babel-编译器执行原理（了解）" class="headerlink" title="Babel 编译器执行原理（了解）"></a>Babel 编译器执行原理（了解）</h3><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483448938446.jpg" srcset="/img/loading.gif"></p>
<h3 id="Babel-loader"><a href="#Babel-loader" class="headerlink" title="Babel-loader"></a>Babel-loader</h3><p>Webpack 对代码进行打包时，并不会将使用 ES6 编写的代码转换成 ES5，这样会存在一个问题：  </p>
<p>如果用户使用的浏览器不支持 ES6 语法，就会导致无法正常使用我们的服务。   </p>
<p>babel-loader：将 Babel 和 Webpack 结合起来，加载所有 js 结尾的文件，如果文件中含有 ES6 语法编写的代码，就会将 ES6 语法转换成 ES5。   </p>
<p>安装 babel-loader：   </p>
<pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span><span class="hljs-keyword">babel-loader </span>-D</code></pre>

<p>如果前面没有安装过 @babel/core，在安装 babel-loader 时也要同时安装：   </p>
<pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span><span class="hljs-keyword">babel-loader </span>@<span class="hljs-keyword">babel/core </span>-D</code></pre>

<p>安装之后，在 <code>webpack.config.js</code> 中添加配置：  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483463722835.jpg" srcset="/img/loading.gif"></p>
<p>因为用到的插件比较多，我们还可以使用 babel 预设，替代上面的插件：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483466039248.jpg" srcset="/img/loading.gif"></p>
<h3 id="Babel-的配置文件"><a href="#Babel-的配置文件" class="headerlink" title="Babel 的配置文件"></a>Babel 的配置文件</h3><p>像之前学习的 postcss 一样，我们可以把放在 <code>webpack.config.js</code> 中的 babel 配置信息，放到一个单独的文件中。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483468582440.jpg" srcset="/img/loading.gif"></p>
<p>更常见的是使用第一种配置文件，创建 <code>babel.config.js</code>文件。   </p>
<p>在根目录下创建 <code>babel.config.js</code>文件：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483471767368.jpg" srcset="/img/loading.gif"></p>
<p>接着在 <code>webpack.config.js</code> 调整一下之前的配置，可以写得很简洁了：       </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483472441529.jpg" srcset="/img/loading.gif"></p>
<h2 id="Vue-源码的打包"><a href="#Vue-源码的打包" class="headerlink" title="Vue 源码的打包"></a>Vue 源码的打包</h2><p>首先要安装 Vue，在命令行中运行：  </p>
<pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> vue</code></pre>

<p>这一次不需要在 vue 后面加上 <code>-D</code> 的参数，因为 Vue 不仅是在开发时需要用到，项目正式上线的时候，也会用到 Vue。  </p>
<p>Vue 有多个版本，大致分为两个： </p>
<ul>
<li>runtime + compiler(后面的 compiler 可以用来解析 Vue 代码中的 template 模板)</li>
<li>runtime-only(这个版本的体积比较小，不支持对 template 模板进行解析)     </li>
</ul>
<p>直接使用 <code>import &#123; createApp &#125; from &#39;vue&#39;</code> 引入的 Vue 是 runtime-only 的版本，无法解析 template 模板，最终在 html 页面无法显示出来。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483500443459.jpg" srcset="/img/loading.gif"></p>
<p>Vue 和 Webpack 一起使用，引入时需要使用包含 compiler 的 Vue 版本：   </p>
<pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue/dist/vue.esm-bundler&#x27;</span></code></pre>

<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483517602689.jpg" srcset="/img/loading.gif"></p>
<p>Vue 开发过程中，有 3 种方式来编写 DOM 元素：   </p>
<ul>
<li>template 模板的方式（之前一直在用的方式）  </li>
<li>render 函数的方式      </li>
<li>通过 <code>.vue</code> 文件中的 template 元素来编写模板      </li>
</ul>
<p>方式一需要通过 Vue 源码中的 compiler 来对 template 模板进行解析；<br>方式三需要用到 vue-loader。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483521098331.jpg" srcset="/img/loading.gif"></p>
<h3 id="VSCode-对-SFC-文件的支持"><a href="#VSCode-对-SFC-文件的支持" class="headerlink" title="VSCode 对 SFC 文件的支持"></a>VSCode 对 SFC 文件的支持</h3><p>SFC：单文件组件    </p>
<p>VS Code 中两个和 SFC 相关的插件：     </p>
<ul>
<li>Vetur    </li>
<li>Volar，Vue 官方推荐的插件</li>
</ul>
<h3 id="Vue-loader"><a href="#Vue-loader" class="headerlink" title="Vue-loader"></a>Vue-loader</h3><p>安装 Vue-loader，同样是开发时依赖：  </p>
<pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> vue-loader -D</code></pre>

<p>配置 Vue-loader：  </p>
<p>在 <code>webpack.config.js</code> 中配置好规则，还需要引入一个 VueLoaderPlugin 插件。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483627350073.jpg" srcset="/img/loading.gif"></p>
<p>控制台会有一个警告信息：  </p>
<p><code>__VUE_OPTIONS_API__</code>：是对 Vue2 进行适配的（Vue2 中会使用 Options，Vue3 开始就去掉了 Options）   </p>
<p><code>__VUE_PROD_DEVTOOLS__</code>：在生产环境是否使用 Vue 调试工具。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483623132086.jpg" srcset="/img/loading.gif"></p>
<p>要去除这个警告信息，可以在 <code>webpack.config.js</code> 的 DefinePlugin 插件中进行配置。   </p>
<p>配置之后，重新进行打包，控制台就不会出现这个警告信息了。    </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483625001041.jpg" srcset="/img/loading.gif"></p>
<p>安装 Vue-loader 之后，内部有一个 <code>@vue/compiler-sfc</code> 模块，会对 template 模板进行解析，这时就不需要用到 Vue 源码中的 compiler。  </p>
<p>因此，我们可以把最开始使用的 runtime + compiler <code>vue.esm-bundler</code> 版本，切换为 只包含 runtime 的 <code>vue</code> 版本。      </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483632760489.jpg" srcset="/img/loading.gif"></p>
<h2 id="Webpack-搭建本地服务器"><a href="#Webpack-搭建本地服务器" class="headerlink" title="Webpack 搭建本地服务器"></a>Webpack 搭建本地服务器</h2><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483722087543.jpg" srcset="/img/loading.gif"></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483725735450.jpg" srcset="/img/loading.gif"></p>
<p>第一种开启 watch 的方式：在 <code>webpack.config.js</code> 的导出配置中，添加 <code>watch: true</code>   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483731701280.jpg" srcset="/img/loading.gif"></p>
<p>在真实开发中，上面这种 watch 的配置方式，其实用得还是比较少。  </p>
<h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><p>上面的方式可以监听到文件的变化，但是事实上它本身是<strong>没有自动刷新浏览器</strong>的功能的：  </p>
<p>因为我们是借助 VS Code 中的 live-server 插件来完成自动刷新浏览器的；   </p>
<p>但是，我们希望在不使用 live-server 插件的情况下，可以具备 <strong>live reloading(实时重新加载)</strong> 的功能。  </p>
<p>安装 webpack-dev-server：   </p>
<pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> webpack-dev-<span class="hljs-keyword">server</span> -D</code></pre>

<p>安装之后，在 <code>package.json</code> 文件的脚本字段，添加配置 <code>&quot;serve&quot;: &quot;webpack serve&quot;</code>。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483979958580.jpg" srcset="/img/loading.gif"></p>
<p>serve通过 webpack-cli 来帮助我们做解析的。   </p>
<p>webpack-dev-serve 在编译之后不会写入到任何输出文件，而是将 bundle 文件保留在<strong>电脑内存</strong>中。webpack-dev-serve 使用了一个 memfs 库。</p>
<p>接着在终端运行 <code>npm run serve</code>，就能看到 Webpack 帮我们搭建的本地服务。  </p>
<p>这个本地服务是基于 Node 的 express 框架搭建的本地服务器。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16483984801008.jpg" srcset="/img/loading.gif"></p>
<p>如果有些资源没有从 Webpack 打包的文件中加载到，就会从 devServer 的 static 中配置的文件夹寻找。  </p>
<p>浏览器向 express 服务器请求某个资源的时候，如果在打包后的资源中找不到，express 就会去 devServer 的 static 中配置的文件夹寻找。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16484760305252.jpg" srcset="/img/loading.gif"></p>
<p>视频中老师用到的 contentBase 字段已经被弃用了。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16484761398900.jpg" srcset="/img/loading.gif"></p>
<p>在真实开发中，如果<strong>希望有些资源在开发阶段暂时不要复制到打包的文件中，加快打包速度</strong>，等到上线(生产)阶段再作复制，就需要给 devServer 的 static 配置路径。   </p>
<p>开发阶段：devServe 的 static 配置文件夹路径 <code>./public</code><br>打包(生产)阶段：使用 CopyWebpackPlugin</p>
<h3 id="认识模块热替换-HMR"><a href="#认识模块热替换-HMR" class="headerlink" title="认识模块热替换(HMR)"></a>认识模块热替换(HMR)</h3><p>HMR 是 Hot Module Replacement，翻译为模块热替换。   </p>
<p>模块热替换是指在<strong>应用程序运行过程中，替换、添加、删除模块</strong>，而<strong>无需重新刷新整个页面</strong>。  </p>
<p>在 Webpack 中，一个文件就可以看成是一个模块。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16484795771943.jpg" srcset="/img/loading.gif"></p>
<h3 id="开启-HMR"><a href="#开启-HMR" class="headerlink" title="开启 HMR"></a>开启 HMR</h3><p>修改 webpack 的配置：  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16484806480170.jpg" srcset="/img/loading.gif"></p>
<p>修改 webpack 配置后，修改文件后依然会刷新整个页面，这是因为我们要去<strong>指定哪些模块发生更新</strong>时，进行 HMR： </p>
<p>增加 if 判断，当 <code>module.hot</code> 为 true，进行模块热替换。       </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16484807844782.jpg" srcset="/img/loading.gif"></p>
<p>开启模块热更新后，浏览器控制台会有下图的提示。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16484811127696.jpg" srcset="/img/loading.gif"></p>
<p>指定模块发生更新进行 HMR 后，当我们修改文件，控制台会打印下面的信息：   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16484811610635.jpg" srcset="/img/loading.gif"></p>
<h3 id="Vue-框架的-HMR"><a href="#Vue-框架的-HMR" class="headerlink" title="Vue 框架的 HMR"></a>Vue 框架的 HMR</h3><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16484814117106.jpg" srcset="/img/loading.gif"></p>
<h3 id="HMR-的原理"><a href="#HMR-的原理" class="headerlink" title="HMR 的原理"></a>HMR 的原理</h3><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16484824990220.jpg" srcset="/img/loading.gif"></p>
<p>Socket 长连接 -&gt; 即时通信（微信、直播间评论区、送礼物、进场消息）<br>长连接：当服务器数据发生变化时，可以主动地向客户端发送请求      </p>
<p>Http 链接 -&gt; 短连接<br>客户端发送 http 请求 -&gt; 和服务器建立连接 -&gt; 服务器做出响应 -&gt; 断开连接    </p>
<p>HMR 原理图   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16484825865854.jpg" srcset="/img/loading.gif"></p>
<h3 id="devServer-的其他配置"><a href="#devServer-的其他配置" class="headerlink" title="devServer 的其他配置"></a>devServer 的其他配置</h3><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16484827807798.jpg" srcset="/img/loading.gif"></p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16484832451168.jpg" srcset="/img/loading.gif"></p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><h3 id="Webpack-的-resolve-模块解析配置"><a href="#Webpack-的-resolve-模块解析配置" class="headerlink" title="Webpack 的 resolve 模块解析配置"></a>Webpack 的 resolve 模块解析配置</h3><p>resolve 用于设置模块如何被解析：   </p>
<ul>
<li>开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库；   </li>
<li>resolve 可以帮助 webpack 从每个 require/import 语句中，找到需要引入的模块代码；   </li>
<li>webpack 使用 enhanced-resolve 库来解析文件路径。    </li>
</ul>
<p>webpack 能解析三种文件路径：  </p>
<ul>
<li>绝对路径</li>
<li>相对路径</li>
<li>模块路径：在 resolve.modules 中指定的所有目录检索模块，默认值是 [‘node_modules’]，所以默认会从 node_modules 中查找文件；    </li>
</ul>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16485622946807.jpg" srcset="/img/loading.gif"></p>
<p>如何确定导入的是一个文件还是文件夹？  </p>
<pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> &#123; sum &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./js/math&quot;</span>;</code></pre>

<p>如何确定导入的 math 是一个文件还是文件夹呢？   </p>
<p>如果是一个文件：   </p>
<ul>
<li>如果文件具有扩展名，则直接打包文件；   </li>
<li>否则，将使用 resolve.extensions 选项作为文件扩展名解析；    </li>
</ul>
<p>resolve.extensions 默认配置了一些扩展名，遇到没有后缀的文件，就会依次为文件加上后缀，去匹配文件夹中是否有对应的文件。   </p>
<pre><code class="hljs css"><span class="hljs-selector-tag">resolve</span>: &#123;
    <span class="hljs-attribute">extensions</span>: [<span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.json&quot;</span>, <span class="hljs-string">&quot;.mjs&quot;</span>, <span class="hljs-string">&quot;.wasm&quot;</span>]     
&#125;</code></pre>

<p>如果是一个文件夹，会在文件夹中根据 resolve.mainFiles 配置选项中指定的文件顺序查找：   </p>
<ul>
<li>resolve.mainFiles 的默认值是 [“index”]；   </li>
<li>再根据 resolve.extensions 来解析扩展名；  </li>
</ul>
<p>添加额外的扩展名，例如在配置中添加 <code>.vue</code>，之后从 <code>App.vue</code> 导入模块时，文件末尾就不需要带上 <code>.vue</code> 后缀了。   </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16485647015692.jpg" srcset="/img/loading.gif"></p>
<p>alias：可以为路径起<strong>别名</strong>，简化导入模块时路径的书写。  </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16485648915673.jpg" srcset="/img/loading.gif"></p>
<h3 id="开发环境和生产环境分离"><a href="#开发环境和生产环境分离" class="headerlink" title="开发环境和生产环境分离"></a>开发环境和生产环境分离</h3><p>之前我们把所有配置都写在了一个 <code>webpack.config.js</code> 中，里面混合了开发环境和生产环境的配置。   </p>
<p>接下来我们要对其进行分离，将配置写到两个不同的文件中。  </p>
<p>在根目录下创建一个 config 的文件夹，创建 3 个配置文件，一个公共的配置文件(comm)，一个是开发环境的配置文件(dev)，一个是生产环境的配置文件(prod)。       </p>
<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16486488190016.jpg" srcset="/img/loading.gif"></p>
<p>接着修改 <code>package.json</code> 中的配置信息：  </p>
<p>给脚本的 build 和 serve 字段后面添加额外的配置，这样我们在终端中运行 <code>npm run build</code> 和 <code>npm run serve</code> 才不会报错。   </p>
<pre><code class="hljs 1c"><span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --config ./config/webpack.prod.config.js&quot;</span>,    
<span class="hljs-string">&quot;serve&quot;</span>: <span class="hljs-string">&quot;webpack serve --config ./config/webpack.dev.config.js&quot;</span></code></pre>

<p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16486488999177.jpg" srcset="/img/loading.gif"></p>
<h2 id="Vue-CLI-脚手架"><a href="#Vue-CLI-脚手架" class="headerlink" title="Vue CLI 脚手架"></a>Vue CLI 脚手架</h2><p><img src="https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16486491520254.jpg" srcset="/img/loading.gif"></p>
<p>Vue CLI 本质上是一个工具，在使用之前需要先安装。  </p>
<h3 id="Vue-CLI-安装和使用"><a href="#Vue-CLI-安装和使用" class="headerlink" title="Vue CLI 安装和使用"></a>Vue CLI 安装和使用</h3><p>全局安装 Vue CLI：  </p>
<pre><code class="hljs angelscript">npm install @vue/<span class="hljs-symbol">cli@</span><span class="hljs-number">4.5</span><span class="hljs-number">.13</span> -g</code></pre>

<p>老师视频中安装的是 4.5.13 版本的脚手架，这里也安装相同的版本。   </p>
<p>安装好之后，通过 vue 的命令来创建项目：  </p>
<pre><code class="hljs awk">vue create 项目的名称   
```   

在 Mac 电脑上使用 `vue create 项目的名称` 创建项目可能会报错，报错信息：  

```       

gyp: No Xcode or CLT version detected!   
```     

解决方法：   

在终端分别输入两行命令  

```   

sudo rm -rf $(xcode-select -print-path)   
sudo xcode-select --install     
```       

之后重新运行创建 vue 项目的命令，覆盖之前创建的东西。   


用 Vue 脚手架创建的 demo 项目的目录，结构和前面学习的 Webpack 非常像：      

![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16487356417880</span>.jpg)


`.browserslistrc` 文件：设置适配浏览器的范围


<span class="hljs-comment">## 认识 Vite</span>

Vite 是尤雨溪写的构建工具。   

![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16489530669622</span>.jpg)

<span class="hljs-comment">### Vite 的构造   </span>

Vite 由两部分组成：   

* 一个开发服务器，它基于原生 ES 模块，提供了丰富的内建功能，HMR（模块热替换）的速度非常快速   
* 在构建阶段，它是一套构建指令，使用 rollup 打开我们的代码，并且它是预配置的，可以输出生产环境的优化过的静态资源    

![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16489541314670</span>.jpg)

版本比较新的浏览器支持 ES Module（**原生浏览器也是支持 ES Module 的**），不需要使用构建工具，也可以识别 ES Module 的代码。    

在 `index.html` 中引入包含 ES Module 的 js 文件，需要给 script 标签增加一个属性 type。  

![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16489580248866</span>.jpg)


但这也存在一些弊端：  

* 浏览器无法识别某些文件，例如 ts、vue、less、scss    
* 如果用到的包，之间的依赖太多，会发送过多的网络请求    

因为存在这些弊端，我们还是需要使用构建工具。这两个弊端，就是 Vite 想帮我们解决的。   

<span class="hljs-comment">### Vite 的安装和使用  </span>

Vite 本身也是依赖 Node 的，所以也需要安装好 Node 环境。  

Vite 要求 Node 版本是大于 <span class="hljs-number">12</span> 版本的。  

全局安装与局部安装 Vite：  
</code></pre>
<p>npm install vite -g<br>npm install vite -D    </p>
<pre><code class="hljs awk">
<span class="hljs-comment">### Vite 对 css、less 和 postcss 的处理   </span>

![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16489652801181</span>.jpg)

Vite 对 css 的处理，不像 webpack 需要安装 css-loader、style-loader，内部的代码可以直接对 css 进行处理。   

Vite 对 less 的处理，需要安装 less 工具：  
</code></pre>
<p>npm install less -D     </p>
<pre><code class="hljs awk">
Vite 对 postcss 的处理，用来添加浏览器前缀，需要安装 `postcss` 和 `postcss-preset-env`。  

![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16489651769542</span>.jpg)

在使用 postcss 时，需要在根目录创建一个配置文件 `postcss.config.js`：      

![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16489652259662</span>.jpg)


<span class="hljs-comment">### Vite 对 TypeScript 的支持   </span>

Vite 对 TypeScript 是原生支持的。    

![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16489662171165</span>.jpg)

<span class="hljs-comment">### Vite 本地服务器的原理     </span>

Vite 在本地搭建了一个服务器，基于 Connect 库，Vite 会将我们编写的 `mul.ts`、`title.less` 文件分别转换(编译)为 **ES6 的 js 代码**。  

当浏览器向本地服务器请求数据时，Vite 会将这些请求**拦截**，并**转发**给编译后的 ES6 js 代码，再将这些代码返回给浏览器。   

<span class="hljs-comment">### Vite 对 Vue 的支持   </span>


![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16490002332134</span>.jpg)

Vite 在处理 Vue <span class="hljs-number">3</span> 单文件组件(`App.vue` 文件)之前，需要安装插件 `@vitejs/plugin-vue`。  

安装插件之后，需要在根目录下创建一个配置文件 `vite.config.js`。   

![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16490016375055</span>.jpg)

在 coderwhy 老师的视频中，添加配置文件后，运行 `npx vite` 还是会报错，这是因为这个插件还会依赖一个模块 `@vitejs/plugin-vue`。   

![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16490014994457</span>.jpg)

但在新版的 Vite 中，已经不需要安装这个模块 `@vitejs/plugin-vue` 了。  

<span class="hljs-comment">### Vite 打包项目  </span>

完成开发后，在将项目部署到服务器之前，需要对项目进行打包（构建），Vite 也提供了打包的命令：  
</code></pre>
<p>npx vite build    </p>
<pre><code class="hljs plain">
测试打包之后的文件是否有问题，可以运行另外一个命令：  
</code></pre>
<p>npx vite preview   </p>
<pre><code class="hljs awk">
在 `package.json` 的 scripts 字段添加相关的配置，就可以把之前的预览命令由 `npx vite preview` 替换为 `npm run preview`。    

![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16490026147789</span>.jpg)


<span class="hljs-comment">### ESBuild 解析  </span>

Vite 打包的速度非常快，是因为它用到了 ESBuild。   

ESBuild 有点像是之前学习过的 Babel，但相对来说，ESBuild 的速度更快。      
ESBuild 是用 Go 语言实现的，而不是 JS。   

![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16490029090297</span>.jpg)


![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16490033471983</span>.jpg)


<span class="hljs-comment">### Vite 架手脚</span>

![](https:<span class="hljs-regexp">//</span>article-picbed-<span class="hljs-number">1302715071</span>.cos.ap-guangzhou.myqcloud.com<span class="hljs-regexp">/2022/</span><span class="hljs-number">04</span><span class="hljs-regexp">/04/</span><span class="hljs-number">16490036509066</span>.jpg)


全局安装脚手架： 
</code></pre>
<p>npm install @vitejs/create-app -g   </p>
<pre><code>
安装 Vite 脚手架之后，在终端输入 `create-app + 项目名称`，就可以快速创建出一个使用 Vite 作为构建工具的项目。   

![](https://article-picbed-1302715071.cos.ap-guangzhou.myqcloud.com/2022/04/04/16490040081962.jpg)

</code></pre>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a>
                    
                      <a class="hover-with-bg" href="/tags/Vue/">Vue</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/16/2022-4-16-4399games/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">怀旧！电脑上怎么玩4399小游戏？</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/06/2022-3-6-videocover/">
                        <span class="hidden-mobile">电脑上如何给视频设置封面？</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "jdElMNU0cUs0Do7VY86SW5eF-gzGzoHsz",
          app_key: "W1C4SSU2QtkkD5pD5uSCV2Hi",
          placeholder: "🌅快来评论一下吧，评论的时候可以写下你可爱的昵称哦ヾﾉ≧∀≦)o",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "",
        });
      });
    }
    waitElementVisible('vcomments', loadValine);
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->




    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">粤ICP备2020100125号-1</a>
    
  </div>


      

          <!-- 在网页底部添加本站已运行的时间 -->
          <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
          <script>
            var now = new Date();
            function createtime() {
              var grt = new Date("10/15/2020 23:49:00");//在此处修改你的建站时间
              now.setTime(now.getTime() + 250);
              days = (now - grt) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
              hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
              if (String(hnum).length == 1) { hnum = "0" + hnum; } minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
              mnum = Math.floor(minutes); if (String(mnum).length == 1) { mnum = "0" + mnum; }
              seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
              snum = Math.round(seconds); if (String(snum).length == 1) { snum = "0" + snum; }
              document.getElementById("timeDate").innerHTML = "本站已运行 " + dnum + " 天 ";
              document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
            }
            setInterval("createtime()", 250);
          </script>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer>
  (function () {
    // 查询存储的记录
    function getRecord(Counter, target) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {target, time: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    }

    // 发起自增请求
    function increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    }

    // 构建自增请求体
    function buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "time": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    }

    // 校验是否为有效的 UV
    function validUV() {
      var key = 'LeanCloud_UV_Flag';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    }

    function addCount(Counter) {
      var enableIncr = 'true' === 'true' && window.location.hostname !== 'localhost';
      var getterArr = [];
      var incrArr = [];

      // 请求 PV 并自增
      var pvCtn = document.querySelector('#leancloud-site-pv-container');
      if (pvCtn || enableIncr) {
        var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
          incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-pv');
          if (ele) {
            ele.innerText = record.time + 1;
            if (pvCtn) {
              pvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#leancloud-site-uv-container');
      if (uvCtn || enableIncr) {
        var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
          var vuv = validUV();
          vuv && incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-uv');
          if (ele) {
            ele.innerText = record.time + (vuv ? 1 : 0);
            if (uvCtn) {
              uvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(uvGetter);
      }

      // 如果是文章，请求文章的浏览数，并自增
      if ('true' === 'true') {
        var viewCtn = document.querySelector('#leancloud-post-views-container');
        if (viewCtn || enableIncr) {
          var target = decodeURI('/2022/04/04/2022-4-4-vue3learnnote/');
          var viewGetter = getRecord(Counter, target).then((record) => {
            incrArr.push(buildIncrement(record.objectId))
            if (viewCtn) {
              var ele = document.querySelector('#leancloud-post-views');
              if (ele) {
                ele.innerText = (record.time || 0) + 1;
                viewCtn.style.display = 'inline';
              }
            }
          });
          getterArr.push(viewGetter);
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && increment(Counter, incrArr);
        })
      }
    }

    var app_id = 'mFS2oVoiTOElp63tFewejr7m-gzGzoHsz'
    var app_key = '0HcqFXhoeStKHmFebO3wbd01'
    var server_url = ''

    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': app_id,
            'X-LC-Key': app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };

      addCount(Counter);
    }

    var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(resp => resp.json())
        .then(({api_server}) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>






  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "前端框架 Vue3 学习笔记（一）&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>












  

  

  

  

  

  




</body>
</html>